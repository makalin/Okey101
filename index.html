<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Okey101 - Traditional Tile Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1b5e20;
            --secondary-color: #388e3c;
            --accent-color: #4caf50;
            --text-light: #e0e0e0;
            --text-dark: #333333;
            --button-primary: #0288d1;
            --button-hover: #0277bd;
            --button-disabled: #78909c;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-dark: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2e2e2e;
            background-image: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            font-family: 'Poppins', 'Segoe UI', Arial, sans-serif;
            transition: background-color 0.5s;
            overflow: hidden;
        }

        .game-container {
            background: var(--primary-color);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 30px var(--shadow-dark), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            position: relative;
            text-align: center;
            max-width: 95vw;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .game-container:hover {
            box-shadow: 0 12px 40px var(--shadow-dark), inset 0 1px 1px rgba(255, 255, 255, 0.2);
        }

        #gameCanvas {
            border: 3px solid #1a472a;
            background-color: var(--secondary-color);
            border-radius: 10px;
            box-shadow: inset 0 0 10px var(--shadow-dark);
            transition: box-shadow 0.3s;
        }

        #status {
            font-size: 20px;
            color: var(--text-light);
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px var(--shadow-dark);
            font-weight: 500;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 30px;
            display: inline-block;
            transition: background-color 0.3s;
        }

        #controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            border: none;
            border-radius: 8px;
            background-color: var(--button-primary);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            box-shadow: 0 4px 6px var(--shadow-dark);
            min-width: 120px;
        }

        button:hover {
            background-color: var(--button-hover);
            transform: translateY(-3px);
            box-shadow: 0 6px 10px var(--shadow-dark);
        }

        button:active {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px var(--shadow-dark);
        }

        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px var(--shadow-dark);
            opacity: 0.7;
        }

        .opponent-area {
            position: absolute;
            color: var(--text-light);
            font-size: 16px;
            font-weight: 500;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            transition: background-color 0.3s, transform 0.3s;
        }

        .opponent-active {
            background-color: rgba(76, 175, 80, 0.3);
            transform: scale(1.05);
        }

        #opponent1 { top: 20px; left: 50%; transform: translateX(-50%); }
        #opponent2 { top: 50%; left: 10px; transform: translateY(-50%); }
        #opponent3 { top: 50%; right: 10px; transform: translateY(-50%); }
        
        #player-area {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-light);
            font-size: 16px;
            font-weight: 500;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            transition: background-color 0.3s;
        }
        
        .player-active {
            background-color: rgba(76, 175, 80, 0.3) !important;
        }

        /* Game Info Panel */
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-light);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            text-align: left;
            font-size: 14px;
            z-index: 100;
            transform: translateX(120%);
            transition: transform 0.5s ease;
            box-shadow: 0 5px 15px var(--shadow-dark);
        }

        .info-panel.show {
            transform: translateX(0);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 5px;
        }

        .info-panel p {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .info-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 101;
            width: 40px;
            height: 40px;
            background-color: var(--button-primary);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 3px 8px var(--shadow-dark);
            transition: background-color 0.3s, transform 0.3s;
        }

        .info-toggle:hover {
            background-color: var(--button-hover);
            transform: scale(1.1);
        }

        .info-toggle-icon {
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        /* Notification */
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            text-align: center;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
        }

        .notification.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        /* Loading animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Sound control */
        .sound-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 101;
            width: 40px;
            height: 40px;
            background-color: var(--button-primary);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 3px 8px var(--shadow-dark);
            transition: background-color 0.3s, transform 0.3s;
        }

        .sound-toggle:hover {
            background-color: var(--button-hover);
            transform: scale(1.1);
        }

        .sound-toggle-icon {
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        /* Media queries for responsive design */
        @media (max-width: 1100px) {
            #gameCanvas {
                width: 90vw;
                height: auto;
            }
            .game-container {
                padding: 15px;
            }
        }

        @media (max-width: 600px) {
            button {
                padding: 10px 16px;
                font-size: 14px;
                min-width: 100px;
            }
            .opponent-area {
                font-size: 14px;
                padding: 6px 12px;
            }
            #status {
                font-size: 16px;
                padding: 8px 16px;
            }
            .info-panel {
                max-width: 250px;
            }
        }

        /* Hints for draggable tiles */
        .draggable-hint {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-light);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .draggable-hint.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="loading-overlay">
        <div class="spinner"></div>
    </div>

    <div class="game-container">
        <div id="status">Loading Okey101...</div>
        <div id="opponent1" class="opponent-area">Opponent 1</div>
        <div id="opponent2" class="opponent-area">Opponent 2</div>
        <div id="opponent3" class="opponent-area">Opponent 3</div>
        <div id="player-area" class="player-active">Your Hand</div>
        <div class="draggable-hint">Drag tiles to organize them or to discard</div>
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <button id="drawButton">Draw Tile</button>
            <button id="meldButton" disabled>Confirm Melds</button>
            <button id="undoButton" disabled>Undo Move</button>
            <button id="restartButton">New Game</button>
        </div>
    </div>

    <div class="notification" id="notification">Your turn to play!</div>

    <div class="info-toggle" id="infoToggle">
        <div class="info-toggle-icon">i</div>
    </div>

    <div class="sound-toggle" id="soundToggle">
        <div class="sound-toggle-icon">ðŸ”Š</div>
    </div>

    <div class="info-panel" id="infoPanel">
        <h3>How to Play Okey101</h3>
        <p><strong>Objective:</strong> Create valid melds with all your tiles.</p>
        <p><strong>Turns:</strong> Draw a tile, organize your hand into valid melds, then discard one tile.</p>
        <p><strong>Valid Melds:</strong></p>
        <p>- <strong>Sets:</strong> 3-4 tiles of the same number but different colors</p>
        <p>- <strong>Runs:</strong> 3+ consecutive numbers of the same color</p>
        <p>- Jokers can substitute for any tile</p>
        <p><strong>Controls:</strong></p>
        <p>- Click on draw pile or discard pile to take a tile</p>
        <p>- Drag tiles to rearrange your hand</p>
        <p>- Group tiles together to form melds</p>
        <p>- Click "Confirm Melds" to validate your groups</p>
        <p>- Drag a tile to the discard pile to end your turn</p>
    </div>

<script>
// Game constants and variables
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const meldButton = document.getElementById('meldButton');
const undoButton = document.getElementById('undoButton');
const restartButton = document.getElementById('restartButton');
const drawButton = document.getElementById('drawButton');
const notification = document.getElementById('notification');
const infoToggle = document.getElementById('infoToggle');
const infoPanel = document.getElementById('infoPanel');
const soundToggle = document.getElementById('soundToggle');
const loadingOverlay = document.querySelector('.loading-overlay');
const draggableHint = document.querySelector('.draggable-hint');
const playerArea = document.getElementById('player-area');
const opponentAreas = [
    document.getElementById('opponent1'),
    document.getElementById('opponent2'),
    document.getElementById('opponent3')
];

// Canvas size
canvas.width = 1000;
canvas.height = 700;

// Tile properties
const tileWidth = 40;
const tileHeight = 60;
const tileMargin = 6;
const tileColors = {
    red: '#e53935',
    blue: '#1e88e5',
    yellow: '#fdd835',
    black: '#424242',
    joker: '#9575cd'
};

// Game state variables
let tiles = [];
let playerHand = [];
let opponents = [[], [], []];
let drawStack = [];
let discardPile = [];
let meldedTiles = [[], [], [], []];
let draggingTile = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let gameState = 'loading';
let currentPlayer = 0;
let lastMove = null;
let hoverTile = null;
let soundEnabled = true;
let notificationTimeout = null;
let drawStackPosition = { x: 0, y: 0, width: 0, height: 0 };
let discardPilePosition = { x: 0, y: 0, width: 0, height: 0 };
let lastDrawnFrom = null;
let mouseX = 0;
let mouseY = 0;
let opponentTimeout = null;

// Animation properties
const animations = [];

// Sound system
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const sounds = {
    drawTile: createSound(440, 0.1),
    discardTile: createSound(220, 0.1),
    meldSuccess: createSound([440, 550, 660], 0.2),
    gameStart: createSound([440, 550, 660, 880], 0.3),
    gameEnd: createSound([880, 660, 550, 440], 0.3)
};

function createSound(frequency, duration) {
    return function() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        const currentTime = audioContext.currentTime;
        
        if (Array.isArray(frequency)) {
            // Create a sequence of tones
            frequency.forEach((freq, index) => {
                oscillator.frequency.setValueAtTime(freq, currentTime + (index * duration));
            });
        } else {
            oscillator.frequency.setValueAtTime(frequency, currentTime);
        }
        
        gainNode.gain.setValueAtTime(0.5, currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + duration);
        
        oscillator.start(currentTime);
        oscillator.stop(currentTime + duration);
    };
}

// UI settings
const dropZoneHighlight = 'rgba(255, 255, 255, 0.2)';
const validMeldHighlight = 'rgba(76, 175, 80, 0.3)';
const invalidMeldHighlight = 'rgba(244, 67, 54, 0.3)';
const hoverEffect = 'rgba(255, 255, 255, 0.1)';

// Tile class with enhanced visuals
class Tile {
    constructor(number, color, x, y, id) {
        this.number = number;
        this.colorName = color; // 'red', 'blue', 'yellow', 'black'
        this.color = tileColors[color];
        this.x = x;
        this.y = y;
        this.id = id;
        this.targetX = x;
        this.targetY = y;
        this.isJoker = number === 0;
        this.isMelded = false;
        this.isHovered = false;
        this.rotation = 0; // For animation effects
        this.scale = 1; // For animation effects
        this.opacity = 1; // For fade effects
        
        // Random slight rotation for natural look
        this.baseRotation = (Math.random() * 0.03) - 0.015;
    }

    draw() {
        ctx.save();
        
        // Apply transformations
        ctx.translate(this.x + tileWidth/2, this.y + tileHeight/2);
        ctx.rotate(this.rotation + this.baseRotation);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = this.opacity;
        
        // Shadow for depth
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        // Draw background
        ctx.fillStyle = this.color;
        ctx.beginPath();
        const radius = 5; // Rounded corners
        ctx.moveTo(-tileWidth/2 + radius, -tileHeight/2);
        ctx.lineTo(tileWidth/2 - radius, -tileHeight/2);
        ctx.arcTo(tileWidth/2, -tileHeight/2, tileWidth/2, -tileHeight/2 + radius, radius);
        ctx.lineTo(tileWidth/2, tileHeight/2 - radius);
        ctx.arcTo(tileWidth/2, tileHeight/2, tileWidth/2 - radius, tileHeight/2, radius);
        ctx.lineTo(-tileWidth/2 + radius, tileHeight/2);
        ctx.arcTo(-tileWidth/2, tileHeight/2, -tileWidth/2, tileHeight/2 - radius, radius);
        ctx.lineTo(-tileWidth/2, -tileHeight/2 + radius);
        ctx.arcTo(-tileWidth/2, -tileHeight/2, -tileWidth/2 + radius, -tileHeight/2, radius);
        ctx.closePath();
        ctx.fill();
        
        // Border effect
        ctx.strokeStyle = this.isMelded ? '#4caf50' : (this.isHovered ? '#fff' : '#000');
        ctx.lineWidth = this.isMelded ? 3 : (this.isHovered ? 2 : 1);
        ctx.stroke();
        
        // Highlight for hover effect
        if (this.isHovered && !this.isMelded) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fill();
        }
        
        // Draw number
        ctx.fillStyle = '#fff';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.font = this.isJoker ? 'bold 20px Poppins' : 'bold 18px Poppins';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw text with a slight emboss effect
        ctx.fillText(this.isJoker ? 'J' : this.number, 0, 0);
        
        // Draw a subtle pattern or texture on the tile
        if (!this.isJoker) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.07)';
            ctx.fillRect(-tileWidth/4, -tileHeight/4, tileWidth/2, tileHeight/2);
        }
        
        ctx.restore();
    }

    containsPoint(px, py) {
        return px >= this.x && px <= this.x + tileWidth &&
               py >= this.y && py <= this.y + tileHeight;
    }
    
    // Animate picking up a tile
    pickUp() {
        this.scale = 1.1;
        this.rotation = 0.05;
        return this;
    }
    
    // Animate putting down a tile
    putDown() {
        this.scale = 1;
        this.rotation = 0;
        return this;
    }
    
    // Highlight when valid meld
    highlight(isValid) {
        this.isHighlighted = true;
        this.highlightColor = isValid ? validMeldHighlight : invalidMeldHighlight;
        return this;
    }
    
    // Remove highlight
    removeHighlight() {
        this.isHighlighted = false;
        return this;
    }
}

// Enhanced Animation class with easing functions
class Animation {
    constructor(tile, targetX, targetY, duration, easing = 'easeOutQuad', onComplete = null) {
        this.tile = tile;
        this.startX = tile.x;
        this.startY = tile.y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.duration = duration;
        this.startTime = performance.now();
        this.easing = easing;
        this.onComplete = onComplete;
        this.completed = false;
        
        // Store initial rotation and scale
        this.startRotation = tile.rotation;
        this.targetRotation = 0;
        this.startScale = tile.scale;
        this.targetScale = 1;
    }
    
    // Different easing functions for more natural movement
    ease(t) {
        switch(this.easing) {
            case 'linear':
                return t;
            case 'easeInQuad':
                return t * t;
            case 'easeOutQuad':
                return t * (2 - t);
            case 'easeInOutQuad':
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            case 'easeOutBack':
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            default:
                return t;
        }
    }

    update() {
        if (this.completed) return false;
        
        const elapsed = performance.now() - this.startTime;
        const progress = Math.min(elapsed / this.duration, 1);
        const easedProgress = this.ease(progress);
        
        this.tile.x = this.startX + (this.targetX - this.startX) * easedProgress;
        this.tile.y = this.startY + (this.targetY - this.startY) * easedProgress;
        
        // Animate rotation and scale
        this.tile.rotation = this.startRotation + (this.targetRotation - this.startRotation) * easedProgress;
        this.tile.scale = this.startScale + (this.targetScale - this.startScale) * easedProgress;
        
        if (progress >= 1) {
            this.completed = true;
            this.tile.x = this.targetX;
            this.tile.y = this.targetY;
            this.tile.rotation = this.targetRotation;
            this.tile.scale = this.targetScale;
            
            if (this.onComplete) {
                this.onComplete();
            }
            return false;
        }
        
        return true;
    }
}

// Opponent AI logic
function playOpponentTurn(opponentIndex) {
    if (gameState !== 'opponent' || currentPlayer !== opponentIndex + 1) return;
    
    const opponent = opponents[opponentIndex];
    const opponentMelds = meldedTiles[opponentIndex + 1];
    
    // Check for valid melds in hand
    const validMelds = checkMelds(opponent);
    if (validMelds.length > 0) {
        // Play the first valid meld
        const meld = validMelds[0];
        meld.forEach(tile => {
            tile.isMelded = true;
            const index = opponent.indexOf(tile);
            if (index !== -1) {
                opponent.splice(index, 1);
            }
        });
        opponentMelds.push(meld);
        if (soundEnabled) sounds.meldSuccess();
    }
    
    // Draw a tile
    if (opponent.length < 14) {
        const tile = drawStack.pop() || discardPile.pop();
        if (tile) {
            opponent.push(tile);
            if (soundEnabled) sounds.drawTile();
        }
    }
    
    // Try to form new melds with the drawn tile
    const newMelds = checkMelds(opponent);
    if (newMelds.length > 0) {
        const meld = newMelds[0];
        meld.forEach(tile => {
            tile.isMelded = true;
            const index = opponent.indexOf(tile);
            if (index !== -1) {
                opponent.splice(index, 1);
            }
        });
        opponentMelds.push(meld);
        if (soundEnabled) sounds.meldSuccess();
    }
    
    // Discard a tile
    if (opponent.length > 0) {
        // Simple strategy: discard the highest number tile that's not part of a meld
        const nonMelded = opponent.filter(tile => !tile.isMelded);
        if (nonMelded.length > 0) {
            nonMelded.sort((a, b) => b.number - a.number);
            const tileToDiscard = nonMelded[0];
            const index = opponent.indexOf(tileToDiscard);
            if (index !== -1) {
                opponent.splice(index, 1);
                discardPile.push(tileToDiscard);
                if (soundEnabled) sounds.discardTile();
            }
        }
    }
    
    // Move to next player
    currentPlayer = (currentPlayer + 1) % 4;
    if (currentPlayer === 0) {
        gameState = 'player';
        updateStatusMessage('Your turn: Draw a tile!');
    } else {
        updateStatusMessage(`Opponent ${currentPlayer}'s turn`);
        // Schedule next opponent's turn
        opponentTimeout = setTimeout(() => {
            playOpponentTurn(currentPlayer - 1);
        }, 1000);
    }
    
    updateButtonStates();
    updatePlayerIndicators();
}

// Update the mouseup event listener to handle opponent turns
canvas.addEventListener('mouseup', event => {
    if (!draggingTile) return;
    
    // Check if dropping on discard pile
    if (isOverDiscardPile()) {
        const index = playerHand.indexOf(draggingTile);
        if (index !== -1) {
            playerHand.splice(index, 1);
            discardPile.push(draggingTile);
            if (soundEnabled) sounds.discardTile();
            
            // End turn and start opponent turns
            gameState = 'opponent';
            currentPlayer = 1;
            updateStatusMessage("Opponent 1's turn");
            updateButtonStates();
            updatePlayerIndicators();
            
            // Start opponent turns
            opponentTimeout = setTimeout(() => {
                playOpponentTurn(0);
            }, 1000);
        }
    }
    
    draggingTile.putDown();
    draggingTile = null;
    updatePlayerHand();
});

// Update the initGame function to clear opponent timeout
function initGame() {
    // Clear any existing opponent timeout
    if (opponentTimeout) {
        clearTimeout(opponentTimeout);
        opponentTimeout = null;
    }
    
    // Show loading
    loadingOverlay.style.opacity = '1';
    loadingOverlay.style.display = 'flex';
    gameState = 'loading';
    
    // Reset game elements
    tiles.length = 0;
    playerHand.length = 0;
    opponents.forEach(op => (op.length = 0));
    drawStack.length = 0;
    discardPile.length = 0;
    meldedTiles.forEach(m => (m.length = 0));
    animations.length = 0;
    
    setTimeout(() => {
        createTiles();
        distributeTiles();
        updatePlayerHand();
        
        gameState = 'player';
        currentPlayer = 0;
        updateStatusMessage('Your turn: Draw a tile!');
        updateButtonStates();
        updatePlayerIndicators();
        
        // Hide loading with a fade out
        loadingOverlay.style.opacity = '0';
        setTimeout(() => {
            loadingOverlay.style.display = 'none';
            showNotification('Game started! Your turn');
            // Show the draggable hint after a short delay
            setTimeout(() => {
                draggableHint.classList.add('show');
                setTimeout(() => {
                    draggableHint.classList.remove('show');
                }, 5000);
            }, 2000);
        }, 500);
    }, 1000);
}

// Create tiles with nice colors
function createTiles() {
    let id = 0;
    const colorNames = ['red', 'blue', 'yellow', 'black'];
    
    for (let colorIndex = 0; colorIndex < 4; colorIndex++) {
        for (let number = 1; number <= 13; number++) {
            for (let i = 0; i < 2; i++) {
                tiles.push(new Tile(number, colorNames[colorIndex], 0, 0, id++));
            }
        }
    }
    // Add jokers
    tiles.push(new Tile(0, 'joker', 0, 0, id++));
    tiles.push(new Tile(0, 'joker', 0, 0, id++));

    // Shuffle with improved animation
    for (let i = tiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
    }
}

// Distribute tiles with animation
function distributeTiles() {
    drawStack = [...tiles];
    
    // Animate distributing to player
    playerHand = drawStack.splice(0, 14);
    
    // Distribute to opponents
    opponents[0] = drawStack.splice(0, 14);
    opponents[1] = drawStack.splice(0, 14);
    opponents[2] = drawStack.splice(0, 14);
    
    // Add one tile to discard pile to start the game
    discardPile.push(drawStack.pop());
}

// Update player hand with improved organization
function updatePlayerHand() {
    const nonMelded = playerHand.filter(tile => !tile.isMelded);
    
    // Sort by color and number for easier organization
    nonMelded.sort((a, b) => {
        if (a.colorName === b.colorName) {
            return a.number - b.number;
        }
        const colorOrder = ['red', 'blue', 'yellow', 'black', 'joker'];
        return colorOrder.indexOf(a.colorName) - colorOrder.indexOf(b.colorName);
    });
    
    const startX = (canvas.width - (nonMelded.length * (tileWidth + tileMargin) - tileMargin)) / 2;
    nonMelded.forEach((tile, index) => {
        tile.targetX = startX + index * (tileWidth + tileMargin);
        tile.targetY = canvas.height - tileHeight - 30;
        
        // Only animate if the tile has moved significantly
        if (Math.abs(tile.x - tile.targetX) > 1 || Math.abs(tile.y - tile.targetY) > 1) {
            animations.push(new Animation(tile, tile.targetX, tile.targetY, 300, 'easeOutQuad'));
        } else {
            tile.x = tile.targetX;
            tile.y = tile.targetY;
        }
    });
}

// Update button states based on game state
function updateButtonStates() {
    meldButton.disabled = !(gameState === 'player' && playerHand.some(tile => !tile.isMelded));
    undoButton.disabled = !lastMove;
    drawButton.disabled = !(gameState === 'player' && playerHand.length === 14);
}

// Update player indicators (who's turn)
function updatePlayerIndicators() {
    playerArea.classList.remove('player-active');
    opponentAreas.forEach(area => area.classList.remove('opponent-active'));
    
    if (currentPlayer === 0) {
        playerArea.classList.add('player-active');
    } else {
        opponentAreas[currentPlayer - 1].classList.add('opponent-active');
    }
}

// Update status message with animation
function updateStatusMessage(message) {
    status.style.opacity = '0';
    setTimeout(() => {
        status.textContent = message;
        status.style.opacity = '1';
    }, 300);
}

// Show notification
function showNotification(message, duration = 2000) {
    if (notificationTimeout) {
        clearTimeout(notificationTimeout);
    }
    notification.textContent = message;
    notification.classList.add('show');
    notificationTimeout = setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// Draw game with enhanced visuals
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw table patterns or textures
    drawTableBackground();
    
    // Draw draw stack with nice 3D effect
    if (drawStack.length > 0) {
        drawDrawStack();
    }

    // Draw discard pile with overlapping tiles effect
    if (discardPile.length > 0) {
        drawDiscardPile();
    }

    // Draw melds with organized layout
    drawMelds();

    // Draw opponents with better visuals
    drawOpponents();

    // Draw player hand
    drawPlayerHand();

    // Draw dragging tile (on top of everything)
    if (draggingTile) draggingTile.draw();
    
    // Draw drop zones when dragging
    if (draggingTile) {
        drawDropZones();
    }
}

// Draw table background
function drawTableBackground() {
    // Create a felt texture pattern
    ctx.fillStyle = '#1b5e20';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add a subtle pattern
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    for (let y = 0; y < canvas.height; y += 20) {
        for (let x = 0; x < canvas.width; x += 20) {
            ctx.fillRect(x, y, 10, 10);
        }
    }
    
    // Draw center table area
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.beginPath();
    ctx.ellipse(canvas.width/2, canvas.height/2, 200, 150, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Add a subtle glow
    ctx.shadowColor = 'rgba(255, 255, 255, 0.1)';
    ctx.shadowBlur = 40;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fill();
    ctx.shadowBlur = 0;
}

// Draw draw stack with 3D effect
function drawDrawStack() {
    const centerX = canvas.width / 2 - tileWidth - 60;
    const centerY = canvas.height / 2 - tileHeight / 2;
    
    // Store the position for interaction
    drawStackPosition = {
        x: centerX,
        y: centerY,
        width: tileWidth,
        height: tileHeight
    };
    
    // Draw stack of tiles with 3D effect
    for (let i = 0; i < Math.min(drawStack.length, 10); i++) {
        const offset = 1.5 * (10 - i);
        ctx.fillStyle = `rgba(200, 200, 200, ${0.7 + i * 0.03})`;
        ctx.fillRect(centerX - offset, centerY - offset, tileWidth, tileHeight);
    }
    
    // Top tile
    ctx.fillStyle = '#ddd';
    ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
    
    // Border
    ctx.strokeStyle = hoverTile === 'drawStack' ? '#fff' : '#000';
    ctx.lineWidth = hoverTile === 'drawStack' ? 2 : 1;
    ctx.strokeRect(centerX, centerY, tileWidth, tileHeight);
    
    // Draw stack count
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Poppins';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 5;
    ctx.fillText(`${drawStack.length}`, centerX + tileWidth/2, centerY + tileHeight/2);
    ctx.shadowBlur = 0;
    
    // Highlight if hovered
    if (hoverTile === 'drawStack') {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
    }
}

// Draw discard pile with overlapping effect
function drawDiscardPile() {
    const centerX = canvas.width / 2 + 20;
    const centerY = canvas.height / 2 - tileHeight / 2;
    
    // Store the position for interaction
    discardPilePosition = {
        x: centerX,
        y: centerY,
        width: tileWidth,
        height: tileHeight
    };
    
    // Draw last few tiles in the discard pile with a staggered effect
    const visibleCount = Math.min(discardPile.length, 3);
    for (let i = 0; i < visibleCount; i++) {
        const index = discardPile.length - 1 - i;
        if (index >= 0) {
            const tile = discardPile[index];
            const offset = i * 5;
            tile.x = centerX - offset;
            tile.y = centerY - offset;
            
            // Create a shadow/duplicate effect for depth
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = tile.color;
            ctx.fillRect(tile.x + 3, tile.y + 3, tileWidth, tileHeight);
            ctx.globalAlpha = 1;
            
            // Make older tiles slightly transparent
            ctx.globalAlpha = 1 - (i * 0.2);
            tile.draw();
            ctx.globalAlpha = 1;
        }
    }
    
    // Highlight if hovered
    if (hoverTile === 'discardPile' && discardPile.length > 0) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
    }
}

// Draw melds with better organization
function drawMelds() {
    meldedTiles.forEach((melds, playerIndex) => {
        melds.forEach((meld, meldIndex) => {
            const y = playerIndex === 0 ? 
                canvas.height - 2 * (tileHeight + 10) - 30 - meldIndex * (tileHeight + 10) :
                20 + meldIndex * (tileHeight + 10);
            
            const xBase = playerIndex === 0 ? 20 : canvas.width - 20 - meld.length * (tileWidth + tileMargin);
            
            // Draw a subtle highlight behind valid melds
            ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
            ctx.fillRect(
                xBase - 5, 
                y - 5, 
                meld.length * (tileWidth + tileMargin) + 10, 
                tileHeight + 10
            );
            
            meld.forEach((tile, tileIndex) => {
                tile.x = xBase + tileIndex * (tileWidth + tileMargin);
                tile.y = y;
                tile.draw();
            });
        });
    });
}

// Draw opponents with better visuals
function drawOpponents() {
    opponents.forEach((hand, index) => {
        const nonMelded = hand.filter(tile => !tile.isMelded);
        
        if (index === 0) {
            // Top opponent
            const startX = (canvas.width - (nonMelded.length * (tileWidth / 2 + tileMargin) - tileMargin)) / 2;
            nonMelded.forEach((_, tileIndex) => {
                const x = startX + tileIndex * (tileWidth / 2 + tileMargin);
                const y = 80;
                
                // Draw a more detailed back of tile
                ctx.fillStyle = '#546e7a';
                ctx.fillRect(x, y, tileWidth / 2, tileHeight / 2);
                
                // Add a pattern to the back
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(x + (tileWidth / 4), y + (tileHeight / 4), tileWidth / 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Add border
                ctx.strokeStyle = '#37474f';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileWidth / 2, tileHeight / 2);
            });
        } else if (index === 1) {
            // Left opponent
            nonMelded.forEach((_, tileIndex) => {
                const x = 80;
                const y = 150 + tileIndex * (tileWidth / 2 + tileMargin);
                
                // Draw a more detailed back of tile
                ctx.fillStyle = '#546e7a';
                ctx.fillRect(x, y, tileHeight / 2, tileWidth / 2);
                
                // Add a pattern to the back
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(x + (tileHeight / 4), y + (tileWidth / 4), tileWidth / 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Add border
                ctx.strokeStyle = '#37474f';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileHeight / 2, tileWidth / 2);
            });
        } else {
            // Right opponent
            nonMelded.forEach((_, tileIndex) => {
                const x = canvas.width - 100;
                const y = 150 + tileIndex * (tileWidth / 2 + tileMargin);
                
                // Draw a more detailed back of tile
                ctx.fillStyle = '#546e7a';
                ctx.fillRect(x, y, tileHeight / 2, tileWidth / 2);
                
                // Add a pattern to the back
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(x + (tileHeight / 4), y + (tileWidth / 4), tileWidth / 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Add border
                ctx.strokeStyle = '#37474f';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileHeight / 2, tileWidth / 2);
            });
        }
    });
}

// Draw player hand with improved visuals
function drawPlayerHand() {
    playerHand.forEach(tile => {
        // Check if tile is being hovered
        if (!draggingTile && tile.containsPoint(mouseX, mouseY) && !tile.isMelded) {
            tile.isHovered = true;
            
            // Simple hover animation - float up slightly
            if (tile.y > tile.targetY - 5) {
                tile.y = tile.targetY - 5;
            }
        } else {
            tile.isHovered = false;
            
            // Return to normal position if not hovered
            if (!draggingTile && !tile.isMelded && Math.abs(tile.y - tile.targetY) > 0.1) {
                tile.y = tile.targetY;
            }
        }
        
        if (tile !== draggingTile && !tile.isMelded) tile.draw();
    });
}

// Draw drop zones when dragging
function drawDropZones() {
    // Discard pile drop zone
    ctx.fillStyle = isOverDiscardPile() ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.05)';
    ctx.beginPath();
    ctx.ellipse(
        discardPilePosition.x + tileWidth/2, 
        discardPilePosition.y + tileHeight/2, 
        tileWidth, tileHeight, 0, 0, Math.PI*2
    );
    ctx.fill();
    
    // Meld area highlight
    const validMelds = checkMelds(playerHand);
    if (validMelds.length > 0) {
        validMelds.forEach(meld => {
            // Get bounding box of the meld
            let minX = Math.min(...meld.map(t => t.x));
            let maxX = Math.max(...meld.map(t => t.x)) + tileWidth;
            let minY = Math.min(...meld.map(t => t.y));
            let maxY = Math.max(...meld.map(t => t.y)) + tileHeight;
            
            // Draw a highlight around valid melds
            ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
            ctx.fillRect(minX - 5, minY - 5, maxX - minX + 10, maxY - minY + 10);
            
            // Draw a border
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.4)';
            ctx.lineWidth = 2;
            ctx.strokeRect(minX - 5, minY - 5, maxX - minX + 10, maxY - minY + 10);
        }); 
    }
}

// Get mouse position relative to canvas
function getMousePosition(event) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}

// Check if mouse is over discard pile
function isOverDiscardPile() {
    if (!draggingTile) return false;
    
    return mouseX >= discardPilePosition.x && 
           mouseX <= discardPilePosition.x + discardPilePosition.width &&
           mouseY >= discardPilePosition.y && 
           mouseY <= discardPilePosition.y + discardPilePosition.height;
}

// Check for valid melds
function checkMelds(hand) {
    const validMelds = [];
    const nonMelded = hand.filter(tile => !tile.isMelded);
    
    // Check for sets (3-4 tiles of same number, different colors)
    const numberGroups = {};
    nonMelded.forEach(tile => {
        if (!numberGroups[tile.number]) {
            numberGroups[tile.number] = [];
        }
        numberGroups[tile.number].push(tile);
    });
    
    Object.values(numberGroups).forEach(group => {
        if (group.length >= 3) {
            validMelds.push(group);
        }
    });
    
    // Check for runs (3+ consecutive numbers of same color)
    const colorGroups = {};
    nonMelded.forEach(tile => {
        if (!colorGroups[tile.colorName]) {
            colorGroups[tile.colorName] = [];
        }
        colorGroups[tile.colorName].push(tile);
    });
    
    Object.values(colorGroups).forEach(group => {
        group.sort((a, b) => a.number - b.number);
        for (let i = 0; i < group.length - 2; i++) {
            if (group[i].number + 1 === group[i + 1].number && 
                group[i + 1].number + 1 === group[i + 2].number) {
                validMelds.push([group[i], group[i + 1], group[i + 2]]);
            }
        }
    });
    
    return validMelds;
}

// Event listeners
canvas.addEventListener('mousemove', event => {
    const mouse = getMousePosition(event);
    mouseX = mouse.x;
    mouseY = mouse.y;
    
    if (draggingTile) {
        draggingTile.x = mouse.x - dragOffsetX;
        draggingTile.y = mouse.y - dragOffsetY;
    }
    
    // Check for hover effects
    hoverTile = null;
    if (mouse.x >= drawStackPosition.x && 
        mouse.x <= drawStackPosition.x + drawStackPosition.width &&
        mouse.y >= drawStackPosition.y && 
        mouse.y <= drawStackPosition.y + drawStackPosition.height) {
        hoverTile = 'drawStack';
    } else if (mouse.x >= discardPilePosition.x && 
               mouse.x <= discardPilePosition.x + discardPilePosition.width &&
               mouse.y >= discardPilePosition.y && 
               mouse.y <= discardPilePosition.y + discardPilePosition.height) {
        hoverTile = 'discardPile';
    }
});

canvas.addEventListener('mousedown', event => {
    if (gameState !== 'player') return;
    
    const mouse = getMousePosition(event);
    
    // Check if clicking draw stack
    if (hoverTile === 'drawStack' && playerHand.length < 14) {
        const tile = drawStack.pop();
        if (tile) {
            playerHand.push(tile);
            lastDrawnFrom = 'stack';
            updatePlayerHand();
            if (soundEnabled) sounds.drawTile();
        }
        return;
    }
    
    // Check if clicking discard pile
    if (hoverTile === 'discardPile' && playerHand.length < 14) {
        const tile = discardPile.pop();
        if (tile) {
            playerHand.push(tile);
            lastDrawnFrom = 'discard';
            updatePlayerHand();
            if (soundEnabled) sounds.discardTile();
        }
        return;
    }
    
    // Check for tile click
    for (let i = playerHand.length - 1; i >= 0; i--) {
        const tile = playerHand[i];
        if (tile.containsPoint(mouse.x, mouse.y) && !tile.isMelded) {
            draggingTile = tile.pickUp();
            dragOffsetX = mouse.x - tile.x;
            dragOffsetY = mouse.y - tile.y;
            break;
        }
    }
});

// Info panel toggle
infoToggle.addEventListener('click', () => {
    infoPanel.classList.toggle('show');
});

// Sound toggle
soundToggle.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    soundToggle.querySelector('.sound-toggle-icon').textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
});

// Game controls
drawButton.addEventListener('click', () => {
    if (gameState === 'player' && playerHand.length < 14) {
        const tile = drawStack.pop();
        if (tile) {
            playerHand.push(tile);
            lastDrawnFrom = 'stack';
            updatePlayerHand();
            if (soundEnabled) sounds.drawTile();
        }
    }
});

meldButton.addEventListener('click', () => {
    if (gameState === 'player') {
        const validMelds = checkMelds(playerHand);
        if (validMelds.length > 0) {
            validMelds.forEach(meld => {
                meld.forEach(tile => {
                    tile.isMelded = true;
                    const index = playerHand.indexOf(tile);
                    if (index !== -1) {
                        playerHand.splice(index, 1);
                    }
                });
                meldedTiles[0].push(meld);
            });
            updatePlayerHand();
            if (soundEnabled) sounds.meldSuccess();
            showNotification('Valid meld!');
        } else {
            showNotification('No valid melds found', 1500);
        }
    }
});

undoButton.addEventListener('click', () => {
    if (lastMove) {
        // Restore last move state
        playerHand = lastMove.hand;
        drawStack = lastMove.stack;
        discardPile = lastMove.discard;
        meldedTiles = lastMove.melds;
        lastMove = null;
        updatePlayerHand();
        updateButtonStates();
    }
});

restartButton.addEventListener('click', () => {
    initGame();
});

// Animation loop
function animate() {
    // Update animations
    for (let i = animations.length - 1; i >= 0; i--) {
        if (!animations[i].update()) {
            animations.splice(i, 1);
        }
    }
    
    // Draw everything
    draw();
    
    // Continue animation loop
    requestAnimationFrame(animate);
}

// Start the game
initGame();
animate();
</script>
</body>
</html>